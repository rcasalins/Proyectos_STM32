/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include "stm32f4xx.h"
#include "GPIOxDriver.h"
#include "USARTxDriver.h"
#include "BasicTimer.h"
#include "AdcDriver.h"
#include "PwmDriver.h"
#include "CaptureFrecDriver.h"
#include <math.h>
#include "SpiDriver.h"

GPIO_Handler_t	handlerLedOK = {0};
BasicTimer_Handler_t handlerStateOKTimer = {0};

GPIO_Handler_t handlerPinPwmChannel = {0};
PWM_Handler_t handlerSignalPWM		= {0};

uint64_t rawDutty = 0;
uint64_t rawDutty_2 = 0;
uint64_t rawDutty_3 = 0;
uint64_t rawDutty_dif = 0;
uint64_t distance = 0;
uint64_t distance_2 = 0;
uint64_t distance_aux = 0;
uint64_t distance_aux_2 = 0;

// Bandera HCSR04
uint8_t flagHCSR04 = 0;
uint8_t flagHCSR04_2 = 0;
uint8_t counterHCSR04 = 0;

GPIO_Handler_t handlerPinCapture	= {0};
Capture_Handler_t handlerCapturaFrec = {0};


GPIO_Handler_t handlerPinCapture2	= {0};
Capture_Handler_t handlerCapturaFrec2 = {0};

GPIO_Handler_t	handlerPinTX = {0};
GPIO_Handler_t	handlerPinRX = {0};
USART_Handler_t handlerCommTerminal = {0};
uint8_t rxData = 0;
char bufferData[64] = "Esto es un prueba \n";

uint16_t duttyValue = 50;

// Bandera captura
uint8_t flagCapture = 0;
uint8_t counterCapture = 0;
uint8_t counterCapture_2 = 0;

uint32_t rawPeriod = 0;

// handler timer delay
BasicTimer_Handler_t handlerDelay = {0};
uint32_t counterDelay = 0;
uint32_t delayTimestamp1 = 0;
uint32_t delayTimestamp2 = 0;
uint32_t delay = 0;

/*
 * Configurando los pines para el SPI
 */
GPIO_Handler_t handlerSpiSCLK 	=	{0};
GPIO_Handler_t handlerSpiMISO 	=	{0};
GPIO_Handler_t handlerSpiMOSI 	= 	{0};
GPIO_Handler_t handlerSpiSS		=	{0};

SPI_Handler_t handlerSpiPort	=	{0};

// Definicion de las cabeceras de las funciones del main
void initSystem(void);
void LEDState(void);
void HCSR04_Configuration(void);
void Serial_Configuration(void);
void SPI_Configuration(void);
void timerDelay_Configuration(void);
uint32_t getCounterDelay(void);
void MatrixLed_writeData(uint8_t digit, uint8_t seg);
void initFrame(void);
void delay_ms(uint16_t newDelayms);
void eyesLeft(void);
void eyesRight(void);
void eyesClose(void);

/**
 * Función principal del programa
 * Esta función es el corazón del programa
 */

int main(void)
{
	// Inicializamos todos los elementos del sistema
	initSystem();

	initFrame();

    /* Loop forever */
	while(1){


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		/*
		 * CAPTURE ENVÍO COMUNICACIÓN SERIAL:
		 * La función getPeriodFreq necesita de dos interrupciones para obtener el valor del periodo,
		 * es por eso que una vez se da la señal de que se debe realizar una captura de frecuencias,
		 * counterCapturer cuenta dos interrupciones (llegando al valor de 3) para proceder a realizar
		 * la lectura del periodo, enviandola por el puerto serial. Luego de ser enviada por el
		 * puerto serial el counterCapturer se resetea y detiene la captura de frecuencias con la
		 * función "stopCapturer" para que las interrupciones se detengan, así no se mantiene realizando
		 * interrupciones infinitamente.
		 */
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		if((counterDelay % 100) == 0){
			// habilitar el counter
			counterCapture = 1;

			// Empezar la captura de frecuencia
			startCapture(&handlerCapturaFrec);
		}

		if(counterCapture != 0){

			// Verificación de que existe una interrupción
			if(flagHCSR04 == 1){

				// Aumento de counter
				counterCapture += 1;

				// Obtención del valor periodo (necesita dos interrupciones)
				// Para mas detaller sobre la función, leer la configuración en el driver
				rawDutty = getDutty(&handlerCapturaFrec);

				// Verificación de que han pasado dos interrupciones
				if(counterCapture == 3){

					distance_aux = ((rawDutty) / 58);

					if(distance_aux < 400){
						distance = distance_aux;
					}

					// Envío del dato por comunicación serial
					sprintf(bufferData, "Distance (cm) = %ld \n", (long unsigned int) distance);
					writeMsg(&handlerCommTerminal, bufferData);

					// reseteo del counter
					counterCapture = 0;

					// Detener captura de frecuencia
					stopCapture(&handlerCapturaFrec);
				}

				// reseteo de la bandera que indica que hubo una interrupción
				flagHCSR04 = 0;
			}
			else{
				__NOP();
			}
		}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		if((counterDelay % 95) == 0){
			// habilitar el counter
			counterCapture_2 = 1;

			// Empezar la captura de frecuencia
			startCapture(&handlerCapturaFrec2);
		}

		if(counterCapture_2 != 0){

			// Verificación de que existe una interrupción
			if(flagHCSR04_2 == 1){

				// Aumento de counter
				counterCapture_2 += 1;

				// Obtención del valor periodo (necesita dos interrupciones)
				// Para mas detaller sobre la función, leer la configuración en el driver
				rawDutty_2 = getDutty_2(&handlerCapturaFrec2);

				// Verificación de que han pasado dos interrupciones
				if(counterCapture_2 == 3){

					distance_aux_2 = ((rawDutty_2) / 58);

					if(distance_aux_2 < 400){
						distance_2 = distance_aux_2;
					}

					// Envío del dato por comunicación serial
					sprintf(bufferData, "Distance_2 (cm) = %ld \n", (long unsigned int) distance_2);
					writeMsg(&handlerCommTerminal, bufferData);

					// reseteo del counter
					counterCapture_2 = 0;

					// Detener captura de frecuencia
					stopCapture(&handlerCapturaFrec2);
				}

				// reseteo de la bandera que indica que hubo una interrupción
				flagHCSR04_2 = 0;
			}
			else{
				__NOP();
			}
		}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		if((distance < 50) & (distance != 0)){

			//delay_ms(100);
			eyesLeft();

		}
		else if((distance_2 < 50) & (distance_2 != 0)){
			eyesRight();
		}
		else{


			if( (counterDelay % 500) == 0){

				eyesClose();
				delay_ms(400);
			}
			else{
				initFrame();
			}
		}

	}
	return 0;
}

void initSystem(void){

	// Configuración LED de estado
	LEDState();

	//Configuración PWM y Captura para HC-SR04
	HCSR04_Configuration();

	// Configuración de la conmunicación serial por el USART 2
	Serial_Configuration();

	// Configuración de la comunicación SPI con la matriz de LEDs
	SPI_Configuration();

	// Configuración de timer generar delays
	timerDelay_Configuration();

}

/*
 * CALLBACKS
 */

// Callback del TIM, hacemos el blinky
//void BasicTimer2_Callback(void){
//	//GPIOxTooglePin(&handlerLedOK);
//}

// Callback comunicación serial
void usart2Rx_Callback(void){
	// Leemos el valor del registro DR, donde se almacena el dato que llega.
	// Esto además debe bajar la bandera de la interrupción
	rxData = getRxData();
}

// Callback de Captura
void CaptureTimer4_Channel3_Callback(void){
	flagHCSR04 = 1;
}

// Callback de Captura 2
void CaptureTimer4_Channel1_Callback(void){
	flagHCSR04_2 = 1;
}

// Callback del TIM, hacemos el delay
void BasicTimer5_Callback(void){
	counterDelay = counterDelay + 1;

	if((counterDelay % 250) == 0){
		GPIOxTooglePin(&handlerLedOK);
	}
}


/*
 * Funciones de inicialización
 */


void delay_ms(uint16_t newDelayms){
	delayTimestamp1 = getCounterDelay();
	delayTimestamp2 = getCounterDelay();

	while((delayTimestamp2 - delayTimestamp1) < newDelayms){
		delayTimestamp2 = getCounterDelay();
	}
}

// Congiguración del LED de estado
void LEDState(void){
	// Organizamos la configuración deseada del pin que controla el LED de la board
	handlerLedOK.pGPIOx								= GPIOA;
	handlerLedOK.GPIO_PinConfig.GPIO_PinNumber		= PIN_5;
	handlerLedOK.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_OUT;
	handlerLedOK.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerLedOK.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerLedOK.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;
	GPIO_Config(&handlerLedOK);
	GPIO_WritePin(&handlerLedOK, SET);

}

void HCSR04_Configuration(void){

	/*
	 * Configuramos el PWM
	 */
	handlerPinPwmChannel.pGPIOx								= GPIOC;
	handlerPinPwmChannel.GPIO_PinConfig.GPIO_PinNumber		= PIN_7;
	handlerPinPwmChannel.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_ALTFN;
	handlerPinPwmChannel.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerPinPwmChannel.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerPinPwmChannel.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;
	handlerPinPwmChannel.GPIO_PinConfig.GPIO_PinAltFunMode	= AF2;
	GPIO_Config(&handlerPinPwmChannel);

	/*
	 * Se configura el periferico del PWM de tal forma que counter aumente cada 1ms (ya que la lectura
	 * del periodo es en milisegundos) y pone un periodo de 200ms
	 */
	handlerSignalPWM.ptrTIMx			= TIM3;
	handlerSignalPWM.config.channel		= PWM_CHANNEL_2;
	handlerSignalPWM.config.duttyCicle	= 6;
	handlerSignalPWM.config.periodo		= 9000;
	handlerSignalPWM.config.prescaler	= 160;

	pwm_Config(&handlerSignalPWM);
	enableOutput(&handlerSignalPWM);
	startPwmSignal(&handlerSignalPWM);

	// Se configura el pin de captura para el primer sensor ultrasonico
	handlerPinCapture.pGPIOx								= GPIOB;
	handlerPinCapture.GPIO_PinConfig.GPIO_PinNumber			= PIN_8;
	handlerPinCapture.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_ALTFN;
	handlerPinCapture.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerPinCapture.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;
	handlerPinCapture.GPIO_PinConfig.GPIO_PinAltFunMode		= AF2;
	GPIO_Config(&handlerPinCapture);

	// COnfiguracion captura para el primer sensor ultrasonico
	handlerCapturaFrec.ptrTIMx						= TIM4;
	handlerCapturaFrec.config.channel				= CAPTURE_CHANNEL_3;
	handlerCapturaFrec.config.edgeSignal			= CAPTURE_RISING_EDGE;
	handlerCapturaFrec.config.prescalerCapture		= CAPTURE_PRESCALER_1_1;
	handlerCapturaFrec.config.timerSpeed			= CAPTURE_TIMER_SPEED_1us;
	capture_Config(&handlerCapturaFrec);

	// COnfiguracion captura para el segundo sensor ultrasonico
	handlerPinCapture2.pGPIOx								= GPIOB;
	handlerPinCapture2.GPIO_PinConfig.GPIO_PinNumber		= PIN_6;
	handlerPinCapture2.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_ALTFN;
	handlerPinCapture2.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerPinCapture2.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;
	handlerPinCapture2.GPIO_PinConfig.GPIO_PinAltFunMode	= AF2;
	GPIO_Config(&handlerPinCapture2);

	// COnfiguracion captura para el primer sensor ultrasonico
	handlerCapturaFrec2.ptrTIMx						= TIM4;
	handlerCapturaFrec2.config.channel				= CAPTURE_CHANNEL_1;
	handlerCapturaFrec2.config.edgeSignal			= CAPTURE_RISING_EDGE;
	handlerCapturaFrec2.config.prescalerCapture		= CAPTURE_PRESCALER_1_1;
	handlerCapturaFrec2.config.timerSpeed			= CAPTURE_TIMER_SPEED_1us;
	capture_Config(&handlerCapturaFrec2);
}

void Serial_Configuration(void){

	/*
	 * Configurando los pines sobre los que funciona el USART
	 */
	handlerPinTX.pGPIOx								= GPIOA;
	handlerPinTX.GPIO_PinConfig.GPIO_PinNumber		= PIN_2;
	handlerPinTX.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_ALTFN;
	handlerPinTX.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerPinTX.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerPinTX.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;
	handlerPinTX.GPIO_PinConfig.GPIO_PinAltFunMode	= AF7;
	GPIO_Config(&handlerPinTX);

	handlerPinRX.pGPIOx								= GPIOA;
	handlerPinRX.GPIO_PinConfig.GPIO_PinNumber		= PIN_3;
	handlerPinRX.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_ALTFN;
	handlerPinRX.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerPinRX.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerPinRX.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;
	handlerPinRX.GPIO_PinConfig.GPIO_PinAltFunMode	= AF7;
	GPIO_Config(&handlerPinRX);

	/*
	 * Configuramos la comunicacion serial
	 */
	handlerCommTerminal.ptrUSARTx						= USART2;
	handlerCommTerminal.USART_Config.USART_datasize		= USART_DATASIZE_8BIT;
	handlerCommTerminal.USART_Config.USART_parity		= USART_PARITY_ODD;
	handlerCommTerminal.USART_Config.USART_stopbits 	= USART_STOPBIT_1;
	handlerCommTerminal.USART_Config.USART_baudrate		= USART_BAUDRATE_115200;
	handlerCommTerminal.USART_Config.USART_mode			= USART_MODE_RXTX;
	handlerCommTerminal.USART_Config.USART_enableIntRX	= USART_RX_INTERRUP_ENABLE;
	USART_Config(&handlerCommTerminal);
}

void SPI_Configuration(void){

	/*
	 * Configuración pines SPI
	 */

	// Clock configuration
	handlerSpiSCLK.pGPIOx								= GPIOB;
	handlerSpiSCLK.GPIO_PinConfig.GPIO_PinNumber		= PIN_3;
	handlerSpiSCLK.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_ALTFN;
	handlerSpiSCLK.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerSpiSCLK.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSpiSCLK.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_HIGH;
	handlerSpiSCLK.GPIO_PinConfig.GPIO_PinAltFunMode	= AF5;
	GPIO_Config(&handlerSpiSCLK);

	// MISO configuration
	handlerSpiMISO.pGPIOx								= GPIOB;
	handlerSpiMISO.GPIO_PinConfig.GPIO_PinNumber		= PIN_4;
	handlerSpiMISO.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_ALTFN;
	handlerSpiMISO.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerSpiMISO.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSpiMISO.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_HIGH;
	handlerSpiMISO.GPIO_PinConfig.GPIO_PinAltFunMode	= AF5;
	GPIO_Config(&handlerSpiMISO);

	// MOSI configuration
	handlerSpiMOSI.pGPIOx								= GPIOB;
	handlerSpiMOSI.GPIO_PinConfig.GPIO_PinNumber		= PIN_5;
	handlerSpiMOSI.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_ALTFN;
	handlerSpiMOSI.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerSpiMOSI.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSpiMOSI.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_HIGH;
	handlerSpiMOSI.GPIO_PinConfig.GPIO_PinAltFunMode	= AF5;
	GPIO_Config(&handlerSpiMOSI);

	// Slave Select configuration
	handlerSpiSS.pGPIOx								= GPIOA;
	handlerSpiSS.GPIO_PinConfig.GPIO_PinNumber		= PIN_9;
	handlerSpiSS.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_OUT;
	handlerSpiSS.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerSpiSS.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSpiSS.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_HIGH;
	GPIO_Config(&handlerSpiSS);

	// handler SPI configuration
	handlerSpiPort.ptrSPIx								= SPI1;
	handlerSpiPort.SPI_Config.SPI_mode					= SPI_MODE_0;
	handlerSpiPort.SPI_Config.SPI_fullDupplexEnable		= SPI_FULL_DUPPLEX;
	handlerSpiPort.SPI_Config.SPI_datasize				= SPI_DATASIZE_8_BIT;
	handlerSpiPort.SPI_Config.SPI_baudrate				= SPI_BAUDRATE_FPCLK_16; // 1MHz
	handlerSpiPort.SPI_slavePin							= handlerSpiSS;
	spi_config(handlerSpiPort);

	//++++++++++++++++++++++++++++++++++++

	uint8_t deCode[2];

	deCode[0] = (0x09);
	deCode[1] = (0x00);

	// Activamos el esclavo
	spi_selectSlave(&handlerSpiPort);

	spi_transmit(handlerSpiPort, deCode, 2);

	// Desactivamos el esclavo
	spi_unSelectSlave(&handlerSpiPort);

	//+++++++++++++++++++++++++++++++++++++++

	uint8_t deScanlimit[2];

	deScanlimit[0] = (0x0B);
	deScanlimit[1] = (0x07);

	// Activamos el esclavo
	spi_selectSlave(&handlerSpiPort);

	spi_transmit(handlerSpiPort, deScanlimit, 2);

	// Desactivamos el esclavo
	spi_unSelectSlave(&handlerSpiPort);

	//+++++++++++++++++++++++++++++++++++++++

	uint8_t shutdown[2];

	shutdown[0] = (0x0C);
	shutdown[1] = (0x01);

	// Activamos el esclavo
	spi_selectSlave(&handlerSpiPort);

	spi_transmit(handlerSpiPort, shutdown, 2);

	// Desactivamos el esclavo
	spi_unSelectSlave(&handlerSpiPort);

	//+++++++++++++++++++++++++++++++++++++++

	uint8_t test[2];

	test[0] = (0x0F);
	test[1] = (0x00);

	// Activamos el esclavo
	spi_selectSlave(&handlerSpiPort);

	spi_transmit(handlerSpiPort, test, 2);

	// Desactivamos el esclavo
	spi_unSelectSlave(&handlerSpiPort);

	//+++++++++++++++++++++++++++++++++++++++

	uint8_t intensity[2];

	intensity[0] = (0x0A);
	intensity[1] = (0x04);

	// Activamos el esclavo
	spi_selectSlave(&handlerSpiPort);

	spi_transmit(handlerSpiPort, intensity, 2);

	// Desactivamos el esclavo
	spi_unSelectSlave(&handlerSpiPort);

	//+++++++++++++++++++++++++++++++++++++++

	MatrixLed_writeData(0x01, 0b00000000);
	MatrixLed_writeData(0x02, 0b00000000);
	MatrixLed_writeData(0x03, 0b00000000);
	MatrixLed_writeData(0x04, 0b00000000);
	MatrixLed_writeData(0x05, 0b00000000);
	MatrixLed_writeData(0x06, 0b00000000);
	MatrixLed_writeData(0x07, 0b00000000);
	MatrixLed_writeData(0x08, 0b00000000);


}

void timerDelay_Configuration(void){

	/*
	 * Configuramos el timer
	 */
	handlerDelay.ptrTIMx							= TIM5;
	handlerDelay.TIMx_Config.TIMx_mode				= BTIMER_MODE_UP;
	handlerDelay.TIMx_Config.TIMx_speed				= BTIMER_SPEED_10us;
	handlerDelay.TIMx_Config.TIMx_period			= 100;
	BasicTimer_Config(&handlerDelay);
}

uint32_t getCounterDelay(void){

	return counterDelay;
}


/*
 * Funciones varias
 */

// Función para escribir valores en la matriz de LEDs a través de SPI
void MatrixLed_writeData(uint8_t digit, uint8_t seg){

	uint8_t data[2];

	// Columna de la matriz que deseamos seleccionar
	data[0] = (digit & 0xF);

	// Fila de la matriz que deseamos seleccionar
	data[1] = seg;

	// Activamos el esclavo
	spi_selectSlave(&handlerSpiPort);

	// Enviamos los datos
	spi_transmit(handlerSpiPort, data, 2);


	// Desactivamos el esclavo
	spi_unSelectSlave(&handlerSpiPort);
};

void initFrame(void){
	MatrixLed_writeData(0x01, 0b00011100);
	MatrixLed_writeData(0x02, 0b01100010);
	MatrixLed_writeData(0x03, 0b10011001);
	MatrixLed_writeData(0x04, 0b10110101);
	MatrixLed_writeData(0x05, 0b10111101);
	MatrixLed_writeData(0x06, 0b10011001);
	MatrixLed_writeData(0x07, 0b01100010);
	MatrixLed_writeData(0x08, 0b00011100);
}

void eyesLeft(void){
	MatrixLed_writeData(0x01, 0b00011100);
	MatrixLed_writeData(0x02, 0b01100010);
	MatrixLed_writeData(0x03, 0b10000001);
	MatrixLed_writeData(0x04, 0b10011001);
	MatrixLed_writeData(0x05, 0b10110101);
	MatrixLed_writeData(0x06, 0b10111101);
	MatrixLed_writeData(0x07, 0b01111010);
	MatrixLed_writeData(0x08, 0b00011100);
}

void eyesRight(void){
	MatrixLed_writeData(0x01, 0b00011100);
	MatrixLed_writeData(0x02, 0b01111010);
	MatrixLed_writeData(0x03, 0b10110101);
	MatrixLed_writeData(0x04, 0b10111101);
	MatrixLed_writeData(0x05, 0b10011001);
	MatrixLed_writeData(0x06, 0b10000001);
	MatrixLed_writeData(0x07, 0b01100010);
	MatrixLed_writeData(0x08, 0b00011100);
}

void eyesClose(void){
	MatrixLed_writeData(0x01, 0b00010000);
	MatrixLed_writeData(0x02, 0b00010000);
	MatrixLed_writeData(0x03, 0b00010000);
	MatrixLed_writeData(0x04, 0b00010000);
	MatrixLed_writeData(0x05, 0b00010000);
	MatrixLed_writeData(0x06, 0b00010000);
	MatrixLed_writeData(0x07, 0b00010000);
	MatrixLed_writeData(0x08, 0b00010000);
}

