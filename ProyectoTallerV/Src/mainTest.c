/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include "stm32f4xx.h"
#include "GPIOxDriver.h"
#include "USARTxDriver.h"
#include "BasicTimer.h"
#include "AdcDriver.h"
#include "PwmDriver.h"
#include "CaptureFrecDriver.h"
#include <math.h>
#include "SpiDriver.h"

GPIO_Handler_t	handlerLedOK = {0};
BasicTimer_Handler_t handlerStateOKTimer = {0};

GPIO_Handler_t handlerPinPwmChannel = {0};
PWM_Handler_t handlerSignalPWM		= {0};

uint64_t rawDutty = 0;
uint64_t rawDutty_2 = 0;
uint64_t distance = 0;
uint64_t distance_2 = 0;
uint64_t distance_aux = 0;
uint64_t distance_aux_2 = 0;

// Bandera HCSR04
uint8_t flagHCSR04 = 0;
uint8_t flagHCSR04_2 = 0;
uint8_t counterHCSR04 = 0;

GPIO_Handler_t handlerPinCapture	= {0};
Capture_Handler_t handlerCapturaFrec = {0};


GPIO_Handler_t handlerPinCapture2	= {0};
Capture_Handler_t handlerCapturaFrec2 = {0};

GPIO_Handler_t	handlerPinTX = {0};
GPIO_Handler_t	handlerPinRX = {0};
USART_Handler_t handlerCommTerminal = {0};
uint8_t rxData = 0;
char bufferData[64] = "Esto es un prueba \n";

uint16_t duttyValue = 50;

// Bandera captura
uint8_t flagCapture = 0;
uint8_t counterCapture = 0;
uint8_t counterCapture_2 = 0;

uint32_t rawPeriod = 0;

// handler timer delay
BasicTimer_Handler_t handlerDelay = {0};
uint32_t counterDelay = 0;
uint32_t delayTimestamp1 = 0;
uint32_t delayTimestamp2 = 0;
uint32_t delay = 0;

/*
 * Configurando los pines para el SPI
 */
GPIO_Handler_t handlerSpiSCLK 	=	{0};
GPIO_Handler_t handlerSpiMISO 	=	{0};
GPIO_Handler_t handlerSpiMOSI 	= 	{0};
GPIO_Handler_t handlerSpiSS		=	{0};

SPI_Handler_t handlerSpiPort	=	{0};

// Definicion de las cabeceras de las funciones del main
void initSystem(void);
void LEDState(void);
void HCSR04_Configuration(void);
void Serial_Configuration(void);
void SPI_Configuration(void);
void timerDelay_Configuration(void);
uint32_t getCounterDelay(void);
void MatrixLed_writeData(uint8_t digit, uint8_t seg);
void initFrame(void);
void delay_ms(uint16_t newDelayms);
void eyesLeft(void);
void eyesRight(void);
void eyesClose(void);

/**
 * Función principal del programa
 * Esta función es el corazón del programa
 */

int main(void)
{
	// Inicializamos todos los elementos del sistema
	initSystem();

	//initFrame();

    /* Loop forever */
	while(1){

		if((counterDelay % 150) == 0){
			// habilitar el counter
			counterCapture = 1;

			// Empezar la captura de frecuencia
			startCapture(&handlerCapturaFrec2);
		}

					if(counterCapture != 0){

						// Verificación de que existe una interrupción
						if(flagHCSR04 == 1){

							// Aumento de counter
							counterCapture += 1;

							// Obtención del valor periodo (necesita dos interrupciones)
							// Para mas detaller sobre la función, leer la configuración en el driver
							rawDutty = getDutty(&handlerCapturaFrec2);

							// Verificación de que han pasado dos interrupciones
							if(counterCapture == 3){

								distance_aux = ((rawDutty) / 58);

								if(distance_aux < 400){
									distance = distance_aux;
								}

								// reseteo del counter
								counterCapture = 0;

								// Detener captura de frecuencia
								stopCapture(&handlerCapturaFrec2);
							}

							// reseteo de la bandera que indica que hubo una interrupción
							flagHCSR04 = 0;
						}
						else{
							__NOP();
						}
					}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//		if((distance_2 < 50) & (distance_2 != 0)){
//
//			//delay_ms(100);
//			eyesLeft();
//
//		}
//		else{
//
//
//			if( (counterDelay % 1000) == 0){
//
//				eyesClose();
//				delay_ms(400);
//			}
//			else{
//				initFrame();
//			}
//		}

	}
	return 0;
}

void initSystem(void){

	// Configuración LED de estado
	LEDState();

	//Configuración PWM y Captura para HC-SR04
	HCSR04_Configuration();

	// Configuración de timer generar delays
	timerDelay_Configuration();

}

/*
 * CALLBACKS
 */

// Callback del TIM, hacemos el blinky
//void BasicTimer2_Callback(void){
//	//GPIOxTooglePin(&handlerLedOK);
//}

// Callback comunicación serial
void usart2Rx_Callback(void){
	// Leemos el valor del registro DR, donde se almacena el dato que llega.
	// Esto además debe bajar la bandera de la interrupción
	rxData = getRxData();
}

// Callback de Captura
void CaptureTimer4_Channel1_Callback(void){
	flagHCSR04 = 1;
}

// Callback de Captura
void CaptureTimer4_Channel2_Callback(void){
//	flagHCSR04 = 1;
}

// Callback de Captura 2
void CaptureTimer2_Channel3_Callback(void){
//	flagHCSR04 = 1;
}

// Callback del TIM, hacemos el delay
void BasicTimer5_Callback(void){
	counterDelay = counterDelay + 1;

	if((counterDelay % 250) == 0){
		GPIOxTooglePin(&handlerLedOK);
	}
}


/*
 * Funciones de inicialización
 */


void delay_ms(uint16_t newDelayms){
	delayTimestamp1 = getCounterDelay();
	delayTimestamp2 = getCounterDelay();

	while((delayTimestamp2 - delayTimestamp1) < newDelayms){
		delayTimestamp2 = getCounterDelay();
	}
}

// Congiguración del LED de estado
void LEDState(void){
	// Organizamos la configuración deseada del pin que controla el LED de la board
	handlerLedOK.pGPIOx								= GPIOA;
	handlerLedOK.GPIO_PinConfig.GPIO_PinNumber		= PIN_5;
	handlerLedOK.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_OUT;
	handlerLedOK.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerLedOK.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerLedOK.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;
	GPIO_Config(&handlerLedOK);
	GPIO_WritePin(&handlerLedOK, SET);

}

void HCSR04_Configuration(void){

	/*
	 * Configuramos el PWM
	 */
	handlerPinPwmChannel.pGPIOx								= GPIOC;
	handlerPinPwmChannel.GPIO_PinConfig.GPIO_PinNumber		= PIN_7;
	handlerPinPwmChannel.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_ALTFN;
	handlerPinPwmChannel.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerPinPwmChannel.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerPinPwmChannel.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;
	handlerPinPwmChannel.GPIO_PinConfig.GPIO_PinAltFunMode	= AF2;
	GPIO_Config(&handlerPinPwmChannel);

	/*
	 * Se configura el periferico del PWM de tal forma que counter aumente cada 1ms (ya que la lectura
	 * del periodo es en milisegundos) y pone un periodo de 200ms
	 */
	handlerSignalPWM.ptrTIMx			= TIM3;
	handlerSignalPWM.config.channel		= PWM_CHANNEL_2;
	handlerSignalPWM.config.duttyCicle	= 6;
	handlerSignalPWM.config.periodo		= 9000;
	handlerSignalPWM.config.prescaler	= 160;

	pwm_Config(&handlerSignalPWM);
	enableOutput(&handlerSignalPWM);
	startPwmSignal(&handlerSignalPWM);

	// Se configura el pin de captura para el primer sensor ultrasonico
//	handlerPinCapture.pGPIOx								= GPIOB;
//	handlerPinCapture.GPIO_PinConfig.GPIO_PinNumber			= PIN_8;
//	handlerPinCapture.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_ALTFN;
//	handlerPinCapture.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
//	handlerPinCapture.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;
//	handlerPinCapture.GPIO_PinConfig.GPIO_PinAltFunMode		= AF2;
//	GPIO_Config(&handlerPinCapture);
//
//	// COnfiguracion captura para el primer sensor ultrasonico
//	handlerCapturaFrec.ptrTIMx						= TIM4;
//	handlerCapturaFrec.config.channel				= CAPTURE_CHANNEL_3;
//	handlerCapturaFrec.config.edgeSignal			= CAPTURE_RISING_EDGE;
//	handlerCapturaFrec.config.prescalerCapture		= CAPTURE_PRESCALER_1_1;
//	handlerCapturaFrec.config.timerSpeed			= CAPTURE_TIMER_SPEED_1us;
//	capture_Config(&handlerCapturaFrec);

	// COnfiguracion captura para el segundo sensor ultrasonico
	handlerPinCapture2.pGPIOx								= GPIOB;
	handlerPinCapture2.GPIO_PinConfig.GPIO_PinNumber		= PIN_6;
	handlerPinCapture2.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_ALTFN;
	handlerPinCapture2.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerPinCapture2.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;
	handlerPinCapture2.GPIO_PinConfig.GPIO_PinAltFunMode	= AF2;
	GPIO_Config(&handlerPinCapture2);

	// COnfiguracion captura para el primer sensor ultrasonico
	handlerCapturaFrec2.ptrTIMx						= TIM4;
	handlerCapturaFrec2.config.channel				= CAPTURE_CHANNEL_1;
	handlerCapturaFrec2.config.edgeSignal			= CAPTURE_RISING_EDGE;
	handlerCapturaFrec2.config.prescalerCapture		= CAPTURE_PRESCALER_1_1;
	handlerCapturaFrec2.config.timerSpeed			= CAPTURE_TIMER_SPEED_1us;
	capture_Config(&handlerCapturaFrec2);
}


void timerDelay_Configuration(void){

	/*
	 * Configuramos el timer
	 */
	handlerDelay.ptrTIMx							= TIM5;
	handlerDelay.TIMx_Config.TIMx_mode				= BTIMER_MODE_UP;
	handlerDelay.TIMx_Config.TIMx_speed				= BTIMER_SPEED_10us;
	handlerDelay.TIMx_Config.TIMx_period			= 100;
	BasicTimer_Config(&handlerDelay);
}

uint32_t getCounterDelay(void){

	return counterDelay;
}


/*
 * Funciones varias
 */

// Función para escribir valores en la matriz de LEDs a través de SPI
void MatrixLed_writeData(uint8_t digit, uint8_t seg){

	uint8_t data[2];

	// Columna de la matriz que deseamos seleccionar
	data[0] = (digit & 0xF);

	// Fila de la matriz que deseamos seleccionar
	data[1] = seg;

	// Activamos el esclavo
	spi_selectSlave(&handlerSpiPort);

	// Enviamos los datos
	spi_transmit(handlerSpiPort, data, 2);


	// Desactivamos el esclavo
	spi_unSelectSlave(&handlerSpiPort);
};

void initFrame(void){
	MatrixLed_writeData(0x01, 0b00011100);
	MatrixLed_writeData(0x02, 0b01100010);
	MatrixLed_writeData(0x03, 0b10011001);
	MatrixLed_writeData(0x04, 0b10110101);
	MatrixLed_writeData(0x05, 0b10111101);
	MatrixLed_writeData(0x06, 0b10011001);
	MatrixLed_writeData(0x07, 0b01100010);
	MatrixLed_writeData(0x08, 0b00011100);
}

void eyesLeft(void){
	MatrixLed_writeData(0x01, 0b00011100);
	MatrixLed_writeData(0x02, 0b01100010);
	MatrixLed_writeData(0x03, 0b10000001);
	MatrixLed_writeData(0x04, 0b10011001);
	MatrixLed_writeData(0x05, 0b10110101);
	MatrixLed_writeData(0x06, 0b10111101);
	MatrixLed_writeData(0x07, 0b01111010);
	MatrixLed_writeData(0x08, 0b00011100);
}

void eyesRight(void){
	MatrixLed_writeData(0x01, 0b00011100);
	MatrixLed_writeData(0x02, 0b01111010);
	MatrixLed_writeData(0x03, 0b10110101);
	MatrixLed_writeData(0x04, 0b10111101);
	MatrixLed_writeData(0x05, 0b10011001);
	MatrixLed_writeData(0x06, 0b10000001);
	MatrixLed_writeData(0x07, 0b01100010);
	MatrixLed_writeData(0x08, 0b00011100);
}

void eyesClose(void){
	MatrixLed_writeData(0x01, 0b00010000);
	MatrixLed_writeData(0x02, 0b00010000);
	MatrixLed_writeData(0x03, 0b00010000);
	MatrixLed_writeData(0x04, 0b00010000);
	MatrixLed_writeData(0x05, 0b00010000);
	MatrixLed_writeData(0x06, 0b00010000);
	MatrixLed_writeData(0x07, 0b00010000);
	MatrixLed_writeData(0x08, 0b00010000);
}

